#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
UNDER DEVELOPMENT!

Assemble all JSON terms into a single Markdown page for Jekyll.

- Keeps Jekyll figure includes (no conversion to plain Markdown images).
- Sections rendered as:
    ### <Section Title>
    [figures... each followed by <br>]
    Source: <d-cite ...> [page]
    <body_md>

Usage:
  python database/pyscripts/export_md.py \
    --json-dir database/json \
    --out-md build/wiki_all.md \
    --title "Power Systems Glossary (All Terms)" \
    --author "ps-wiki" \
    --toc --toc-depth 2
"""

import argparse
import json
import sys
from pathlib import Path
from typing import Any, Dict, List, Optional

def slugify_kebab(s: str) -> str:
    import re
    s = (s or "").strip().lower()
    s = re.sub(r"[^a-z0-9]+", "-", s).strip("-")
    return s or "untitled"

def load_term(p: Path) -> Optional[Dict[str, Any]]:
    try:
        return json.loads(p.read_text(encoding="utf-8"))
    except Exception as e:
        print(f"[WARN] failed to parse {p.name}: {e}", file=sys.stderr)
        return None

def render_front_matter_page(title: str, author: str) -> str:
    fm = ["---",
          "layout: page",
          f"title: {title or 'All Terms'}",
          "permalink: /wiki-all/",
          f"description: Combined view of all ps-wiki terms",
          "nav: true",
          "nav_order: 99",
          "---",
          ""]
    if author:
        fm.append(f"_Generated by: {author}_\n")
    return "\n".join(fm) + "\n"

def render_term_header(term: Dict[str, Any]) -> str:
    title = term.get("title") or term.get("id") or ""
    desc = term.get("description", "")
    authors = term.get("authors", []) or []
    dates = term.get("dates", {}) or {}
    created = dates.get("created", "")
    lastmod = dates.get("last_modified", "")
    tags = term.get("tags", []) or []

    # H1 for term
    out = [f"# {title}\n"]
    if desc:
        out.append(f"{desc}\n")
    meta_bits = []
    if authors:
        names = ", ".join([a.get("name") for a in authors if isinstance(a, dict) and a.get("name")])
        if names:
            meta_bits.append(f"**Authors:** {names}")
    if created:
        meta_bits.append(f"**Date:** {created}")
    if lastmod:
        meta_bits.append(f"**Last modified:** {lastmod}")
    if tags:
        meta_bits.append(f"**Tags:** {', '.join(tags)}")
    if meta_bits:
        out.append("  \n".join(meta_bits) + "\n")
    return "\n".join(out).rstrip() + "\n\n"

def render_figure_block(fig: Dict[str, Any]) -> str:
    path = fig.get("path", "")
    zoomable = fig.get("zoomable", True)
    zoom_val = "true" if zoomable else "false"
    caption = fig.get("caption_md", "") or ""

    lines = []
    lines.append('<div class="row mt-3">')
    lines.append('    <div class="col-sm mt-3 mt-md-0">')
    lines.append("        {% include figure.liquid")
    lines.append(f'        path="{path}"')
    # concatenate to avoid f-string brace escaping issues
    lines.append(f"        zoomable={zoom_val} " + "%}")
    if caption:
        lines.append(f"        {caption}")
    lines.append("    </div>")
    lines.append("</div>")
    lines.append("")
    lines.append("<br>")
    lines.append("")
    return "\n".join(lines)

def render_section(sec: Dict[str, Any]) -> str:
    title = sec.get("title", "")
    figs = sec.get("figures", []) or []
    source_keys = sec.get("source_keys", []) or []
    page = sec.get("page", None)
    body = sec.get("body_md", "") or ""

    out: List[str] = []
    out.append(f"### {title}\n")

    for f in figs:
        out.append(render_figure_block(f))

    if source_keys:
        cites = " ".join([f'<d-cite key="{k}"></d-cite>' for k in source_keys])
        page_suffix = f" {page}" if page else ""
        out.append(f"Source: {cites}{page_suffix}\n")

    if body:
        out.append(body.rstrip() + "\n")

    return "\n".join(out).rstrip() + "\n\n"

def build_toc(terms: List[Dict[str, Any]], depth: int = 2) -> str:
    # Simple bullet TOC linking to H1 anchors (Jekyll auto-ids from titles)
    lines = []
    lines.append("## Table of Contents\n")
    for t in terms:
        title = t.get("title") or t.get("id") or ""
        anchor = slugify_kebab(title)
        lines.append(f"- [{title}](#{anchor})")
    lines.append("")  # trailing blank
    return "\n".join(lines) + "\n"

def render_term(term: Dict[str, Any]) -> str:
    out: List[str] = [render_term_header(term)]
    sections = (term.get("content", {}) or {}).get("sections", [])
    sections = sorted(sections, key=lambda s: (s.get("order") is None, s.get("order", 10**9), s.get("title","")))
    for s in sections:
        out.append(render_section(s))
    return "\n".join(out)

def main():
    ap = argparse.ArgumentParser(description="Combine all JSON terms into a single Markdown page for Jekyll.")
    ap.add_argument("--json-dir", default="database/json", help="Directory with term JSON files.")
    ap.add_argument("--out-md", required=True, help="Output Markdown path (e.g., build/wiki_all.md).")
    ap.add_argument("--title", default="Power Systems Glossary (All Terms)", help="Top-level page title.")
    ap.add_argument("--author", default="ps-wiki", help="Attribution line in the page.")
    ap.add_argument("--toc", action="store_true", help="Insert a simple Table of Contents.")
    ap.add_argument("--toc-depth", type=int, default=2, help="TOC depth (not used extensively; headings are per term).")
    args = ap.parse_args()

    json_dir = Path(args.json_dir)
    out_md = Path(args.out_md)
    if not json_dir.exists():
        print(f"ERROR: JSON dir not found: {json_dir}", file=sys.stderr)
        sys.exit(1)

    # Load & sort terms
    terms: List[Dict[str, Any]] = []
    for p in sorted(json_dir.glob("*.json")):
        t = load_term(p)
        if t:
            terms.append(t)
    terms.sort(key=lambda t: (t.get("title") or t.get("id") or ""))

    # Build content
    parts: List[str] = [render_front_matter_page(args.title, args.author)]
    if args.toc:
        parts.append(build_toc(terms, depth=args.toc_depth))

    for t in terms:
        parts.append(render_term(t))

    out_md.parent.mkdir(parents=True, exist_ok=True)
    out_md.write_text("\n".join(parts).rstrip() + "\n", encoding="utf-8")
    print(f"Wrote combined Markdown: {out_md}")

if __name__ == "__main__":
    main()
